"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __importDefault(require("debug"));
var debug = debug_1.default('guillotine-packer:pack-strategy');
var selection_strategies_1 = require("./selection-strategies");
var sort_strategies_1 = require("./sort-strategies");
var split_strategies_1 = require("./split-strategies");
function PackStrategy(_a) {
    var binHeight = _a.binHeight, binWidth = _a.binWidth, items = _a.items, selectionStrategy = _a.selectionStrategy, splitStrategy = _a.splitStrategy, sortStrategy = _a.sortStrategy, sortOrder = _a.sortOrder, kerfSize = _a.kerfSize, allowRotation = _a.allowRotation;
    debug("Executing! split strategy: " + splitStrategy + ", selection strategy: " + selectionStrategy + ", sortStrategy: " + sortStrategy + ", sortOrder: " + sortOrder);
    var binCount = 0;
    var freeRectangles = [];
    var createBin = function () {
        binCount++;
        debug("creating bin " + binCount);
        freeRectangles.push({
            width: binWidth,
            height: binHeight,
            x: 0,
            y: 0,
            bin: binCount,
            id: 'root'
        });
    };
    var splitter = split_strategies_1.GetSplitImplementation(splitStrategy, kerfSize);
    var selector = selection_strategies_1.GetSelectionImplementation(selectionStrategy);
    var sorter = sort_strategies_1.GetSortImplementation(sortStrategy, sortOrder);
    var sortedItems = sorter.sort(items);
    var rotateItem = function (item) {
        return __assign(__assign({}, item), { height: item.width, width: item.height });
    };
    var splitRectangle = function (_a) {
        var rectangle = _a.rectangle, item = _a.item;
        return splitter.split(rectangle, item).filter(function (r) { return r.width > 0 && r.height > 0; });
    };
    var getSelectionOption = function (item) {
        var rectangle = selector.select(freeRectangles, item);
        debug("for item " + JSON.stringify(item) + ", selected " + JSON.stringify(rectangle));
        if (!rectangle) {
            return null;
        }
        var splitRectangles = splitRectangle({ rectangle: rectangle, item: item });
        return {
            rectangle: rectangle,
            splitRectangles: splitRectangles,
            item: item
        };
    };
    var selectRectangleOption = function (item) {
        var originalOption = getSelectionOption(item);
        var rotatedOption = null;
        var rotatedItem;
        if (allowRotation) {
            rotatedItem = rotateItem(item);
            rotatedOption = getSelectionOption(rotatedItem);
        }
        if (originalOption === null && rotatedOption === null) {
            debug("No free rectangles found for", item);
            return null;
        }
        else if (originalOption === null) {
            debug("Original item didn't fit, using rotated", item);
            return rotatedOption;
        }
        else if (rotatedOption === null) {
            debug("Rotated item didn't fit, using original option", item);
            return originalOption;
        }
        else {
            var getBiggestSplitRectangle = function (_a) {
                var splitRectangles = _a.splitRectangles;
                return Math.max.apply(Math, splitRectangles.map(function (split) { return split.height * split.width; }));
            };
            var originalMax = getBiggestSplitRectangle(originalOption);
            var rotatedMax = getBiggestSplitRectangle(rotatedOption);
            debug("Original max area " + originalMax + ", rotated max area " + rotatedMax);
            if (getBiggestSplitRectangle(originalOption) >= getBiggestSplitRectangle(rotatedOption)) {
                debug("Going with original placement option");
                return originalOption;
            }
            else {
                debug("Going with rotated placement option");
                return rotatedOption;
            }
        }
    };
    var packedItems = sortedItems
        .map(function (item, idx) {
        debug('packing item', item);
        var selectedOption = selectRectangleOption(item);
        if (!selectedOption) {
            createBin();
            selectedOption = selectRectangleOption(item);
        }
        if (!selectedOption) {
            throw new Error("item at index " + idx + " with dimensions " + item.width + "x" + item.height + " exceeds bin dimensions of " + binWidth + "x" + binHeight);
        }
        var rectangle = selectedOption.rectangle, splitRectangles = selectedOption.splitRectangles;
        debug('selected rectangle', rectangle);
        var _a = selectedOption.item, width = _a.width, height = _a.height, otherItemProps = __rest(_a, ["width", "height"]);
        var packedItem = {
            item: otherItemProps,
            width: width,
            height: height,
            x: rectangle.x,
            y: rectangle.y,
            bin: rectangle.bin
        };
        debug('packed item', packedItem);
        debug('free rectangles pre split', freeRectangles);
        var rectIndex = freeRectangles.findIndex(function (r) { return r === rectangle; });
        freeRectangles.splice.apply(freeRectangles, __spreadArrays([rectIndex, 1], splitRectangles));
        debug('free rectangles post split', freeRectangles);
        return packedItem;
    })
        .reduce(function (bins, item) {
        if (bins.length >= item.bin) {
            bins[item.bin - 1].push(item);
        }
        else {
            bins.push([item]);
        }
        return bins;
    }, []);
    return {
        sortStrategy: sortStrategy,
        sortOrder: sortOrder,
        packedItems: packedItems,
        splitStrategy: splitStrategy,
        selectionStrategy: selectionStrategy
    };
}
exports.PackStrategy = PackStrategy;
//# sourceMappingURL=pack-strategy.js.map