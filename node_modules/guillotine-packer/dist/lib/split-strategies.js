"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __importDefault(require("debug"));
var debug = debug_1.default('guillotine-packer:split-strategies');
// implementations based off of http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf
var createSplitRectangle = function (rectangle) { return (__assign(__assign({}, rectangle), { splitFrom: rectangle.id })); };
var Splitter = /** @class */ (function () {
    function Splitter(kerfSize) {
        this.kerfSize = kerfSize;
    }
    Splitter.prototype.splitHorizontally = function (rectangle, item) {
        debug("splitting " + rectangle.id + " horizontally");
        var rectangle1 = __assign(__assign({}, createSplitRectangle(rectangle)), { x: rectangle.x + item.width + this.kerfSize, width: rectangle.width - item.width - this.kerfSize, height: item.height, id: 'sh-r1' });
        var rectangle2 = __assign(__assign({}, createSplitRectangle(rectangle)), { y: rectangle.y + item.height + this.kerfSize, height: rectangle.height - item.height - this.kerfSize, id: 'sh-r2' });
        return [rectangle1, rectangle2];
    };
    Splitter.prototype.splitVertically = function (rectangle, item) {
        debug("splitting " + rectangle.id + " vertically");
        var rectangle1 = __assign(__assign({}, createSplitRectangle(rectangle)), { y: rectangle.y + item.height + this.kerfSize, width: item.width, height: rectangle.height - item.height - this.kerfSize, id: 'sh-r1' });
        var rectangle2 = __assign(__assign({}, createSplitRectangle(rectangle)), { x: rectangle.x + item.width + this.kerfSize, y: rectangle.y, width: rectangle.width - item.width - this.kerfSize, id: 'sh-r2' });
        return [rectangle1, rectangle2];
    };
    return Splitter;
}());
var ShortAxisSplit = /** @class */ (function (_super) {
    __extends(ShortAxisSplit, _super);
    function ShortAxisSplit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ShortAxisSplit.prototype.split = function (rectangle, item) {
        if (rectangle.width < rectangle.height) {
            return this.splitHorizontally(rectangle, item);
        }
        else {
            return this.splitVertically(rectangle, item);
        }
    };
    return ShortAxisSplit;
}(Splitter));
var LongAxisSplit = /** @class */ (function (_super) {
    __extends(LongAxisSplit, _super);
    function LongAxisSplit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LongAxisSplit.prototype.split = function (rectangle, item) {
        if (rectangle.width > rectangle.height) {
            return this.splitHorizontally(rectangle, item);
        }
        else {
            return this.splitVertically(rectangle, item);
        }
    };
    return LongAxisSplit;
}(Splitter));
var ShorterLeftoverAxisSplit = /** @class */ (function (_super) {
    __extends(ShorterLeftoverAxisSplit, _super);
    function ShorterLeftoverAxisSplit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ShorterLeftoverAxisSplit.prototype.split = function (rectangle, item) {
        if (rectangle.width - item.width < rectangle.height - item.height) {
            return this.splitHorizontally(rectangle, item);
        }
        else {
            return this.splitVertically(rectangle, item);
        }
    };
    return ShorterLeftoverAxisSplit;
}(Splitter));
var LongerLeftoverAxisSplit = /** @class */ (function (_super) {
    __extends(LongerLeftoverAxisSplit, _super);
    function LongerLeftoverAxisSplit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LongerLeftoverAxisSplit.prototype.split = function (rectangle, item) {
        if (rectangle.width - item.width >= rectangle.height - item.height) {
            return this.splitHorizontally(rectangle, item);
        }
        else {
            return this.splitVertically(rectangle, item);
        }
    };
    return LongerLeftoverAxisSplit;
}(Splitter));
var SplitStrategy;
(function (SplitStrategy) {
    SplitStrategy[SplitStrategy["LongLeftoverAxisSplit"] = 0] = "LongLeftoverAxisSplit";
    SplitStrategy[SplitStrategy["ShortLeftoverAxisSplit"] = 1] = "ShortLeftoverAxisSplit";
    SplitStrategy[SplitStrategy["LongAxisSplit"] = 2] = "LongAxisSplit";
    SplitStrategy[SplitStrategy["ShortAxisSplit"] = 3] = "ShortAxisSplit";
})(SplitStrategy = exports.SplitStrategy || (exports.SplitStrategy = {}));
function GetSplitImplementation(strategy, kerfSize) {
    switch (strategy) {
        case SplitStrategy.LongAxisSplit:
            return new LongAxisSplit(kerfSize);
        case SplitStrategy.ShortAxisSplit:
            return new ShortAxisSplit(kerfSize);
        case SplitStrategy.LongLeftoverAxisSplit:
            return new LongerLeftoverAxisSplit(kerfSize);
        case SplitStrategy.ShortLeftoverAxisSplit:
            return new ShorterLeftoverAxisSplit(kerfSize);
    }
}
exports.GetSplitImplementation = GetSplitImplementation;
//# sourceMappingURL=split-strategies.js.map