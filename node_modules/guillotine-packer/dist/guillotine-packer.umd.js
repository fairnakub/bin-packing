(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tty'), require('util'), require('os')) :
    typeof define === 'function' && define.amd ? define(['exports', 'tty', 'util', 'os'], factory) :
    (global = global || self, factory(global.guillotinePacker = {}, global.tty, global.util, global.os));
}(this, (function (exports, tty, util, os) { 'use strict';

    tty = tty && tty.hasOwnProperty('default') ? tty['default'] : tty;
    util = util && util.hasOwnProperty('default') ? util['default'] : util;
    os = os && os.hasOwnProperty('default') ? os['default'] : os;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = ms;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* Active `debug` instances.
    	*/
    	createDebug.instances = [];

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return match;
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.enabled = createDebug.enabled(namespace);
    		debug.useColors = createDebug.useColors();
    		debug.color = selectColor(namespace);
    		debug.destroy = destroy;
    		debug.extend = extend;
    		// Debug.formatArgs = formatArgs;
    		// debug.rawLog = rawLog;

    		// env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		createDebug.instances.push(debug);

    		return debug;
    	}

    	function destroy() {
    		const index = createDebug.instances.indexOf(this);
    		if (index !== -1) {
    			createDebug.instances.splice(index, 1);
    			return true;
    		}
    		return false;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}

    		for (i = 0; i < createDebug.instances.length; i++) {
    			const instance = createDebug.instances[i];
    			instance.enabled = createDebug.enabled(instance.namespace);
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    var browser = createCommonjsModule(function (module, exports) {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    /**
     * Colors.
     */

    exports.colors = [
    	'#0000CC',
    	'#0000FF',
    	'#0033CC',
    	'#0033FF',
    	'#0066CC',
    	'#0066FF',
    	'#0099CC',
    	'#0099FF',
    	'#00CC00',
    	'#00CC33',
    	'#00CC66',
    	'#00CC99',
    	'#00CCCC',
    	'#00CCFF',
    	'#3300CC',
    	'#3300FF',
    	'#3333CC',
    	'#3333FF',
    	'#3366CC',
    	'#3366FF',
    	'#3399CC',
    	'#3399FF',
    	'#33CC00',
    	'#33CC33',
    	'#33CC66',
    	'#33CC99',
    	'#33CCCC',
    	'#33CCFF',
    	'#6600CC',
    	'#6600FF',
    	'#6633CC',
    	'#6633FF',
    	'#66CC00',
    	'#66CC33',
    	'#9900CC',
    	'#9900FF',
    	'#9933CC',
    	'#9933FF',
    	'#99CC00',
    	'#99CC33',
    	'#CC0000',
    	'#CC0033',
    	'#CC0066',
    	'#CC0099',
    	'#CC00CC',
    	'#CC00FF',
    	'#CC3300',
    	'#CC3333',
    	'#CC3366',
    	'#CC3399',
    	'#CC33CC',
    	'#CC33FF',
    	'#CC6600',
    	'#CC6633',
    	'#CC9900',
    	'#CC9933',
    	'#CCCC00',
    	'#CCCC33',
    	'#FF0000',
    	'#FF0033',
    	'#FF0066',
    	'#FF0099',
    	'#FF00CC',
    	'#FF00FF',
    	'#FF3300',
    	'#FF3333',
    	'#FF3366',
    	'#FF3399',
    	'#FF33CC',
    	'#FF33FF',
    	'#FF6600',
    	'#FF6633',
    	'#FF9900',
    	'#FF9933',
    	'#FFCC00',
    	'#FFCC33'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
    	// NB: In an Electron preload script, document will be defined but not fully
    	// initialized. Since we know we're in Chrome, we'll just detect this case
    	// explicitly
    	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    		return true;
    	}

    	// Internet Explorer and Edge do not support colors.
    	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    		return false;
    	}

    	// Is webkit? http://stackoverflow.com/a/16459606/376773
    	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    		// Is firebug? http://stackoverflow.com/a/398120/376773
    		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    		// Is firefox >= v31?
    		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    		// Double check webkit in userAgent just in case we are in a worker
    		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	args[0] = (this.useColors ? '%c' : '') +
    		this.namespace +
    		(this.useColors ? ' %c' : ' ') +
    		args[0] +
    		(this.useColors ? '%c ' : ' ') +
    		'+' + module.exports.humanize(this.diff);

    	if (!this.useColors) {
    		return;
    	}

    	const c = 'color: ' + this.color;
    	args.splice(1, 0, c, 'color: inherit');

    	// The final "%c" is somewhat tricky, because there could be other
    	// arguments passed either before or after the %c, so we need to
    	// figure out the correct index to insert the CSS into
    	let index = 0;
    	let lastC = 0;
    	args[0].replace(/%[a-zA-Z%]/g, match => {
    		if (match === '%%') {
    			return;
    		}
    		index++;
    		if (match === '%c') {
    			// We only are interested in the *last* %c
    			// (the user may have provided their own)
    			lastC = index;
    		}
    	});

    	args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */
    function log(...args) {
    	// This hackery is required for IE8/9, where
    	// the `console.log` function doesn't have 'apply'
    	return typeof console === 'object' &&
    		console.log &&
    		console.log(...args);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	try {
    		if (namespaces) {
    			exports.storage.setItem('debug', namespaces);
    		} else {
    			exports.storage.removeItem('debug');
    		}
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
    	let r;
    	try {
    		r = exports.storage.getItem('debug');
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}

    	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    	if (!r && typeof process !== 'undefined' && 'env' in process) {
    		r = process.env.DEBUG;
    	}

    	return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
    	try {
    		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    		// The Browser also has localStorage in the global context.
    		return localStorage;
    	} catch (error) {
    		// Swallow
    		// XXX (@Qix-) should we be logging these?
    	}
    }

    module.exports = common(exports);

    const {formatters} = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
    	try {
    		return JSON.stringify(v);
    	} catch (error) {
    		return '[UnexpectedJSONParseError]: ' + error.message;
    	}
    };
    });
    var browser_1 = browser.log;
    var browser_2 = browser.formatArgs;
    var browser_3 = browser.save;
    var browser_4 = browser.load;
    var browser_5 = browser.useColors;
    var browser_6 = browser.storage;
    var browser_7 = browser.colors;

    var hasFlag = (flag, argv) => {
    	argv = argv || process.argv;
    	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
    	const pos = argv.indexOf(prefix + flag);
    	const terminatorPos = argv.indexOf('--');
    	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };

    const env = process.env;

    let forceColor;
    if (hasFlag('no-color') ||
    	hasFlag('no-colors') ||
    	hasFlag('color=false')) {
    	forceColor = false;
    } else if (hasFlag('color') ||
    	hasFlag('colors') ||
    	hasFlag('color=true') ||
    	hasFlag('color=always')) {
    	forceColor = true;
    }
    if ('FORCE_COLOR' in env) {
    	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }

    function translateLevel(level) {
    	if (level === 0) {
    		return false;
    	}

    	return {
    		level,
    		hasBasic: true,
    		has256: level >= 2,
    		has16m: level >= 3
    	};
    }

    function supportsColor(stream) {
    	if (forceColor === false) {
    		return 0;
    	}

    	if (hasFlag('color=16m') ||
    		hasFlag('color=full') ||
    		hasFlag('color=truecolor')) {
    		return 3;
    	}

    	if (hasFlag('color=256')) {
    		return 2;
    	}

    	if (stream && !stream.isTTY && forceColor !== true) {
    		return 0;
    	}

    	const min = forceColor ? 1 : 0;

    	if (process.platform === 'win32') {
    		// Node.js 7.5.0 is the first version of Node.js to include a patch to
    		// libuv that enables 256 color output on Windows. Anything earlier and it
    		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
    		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
    		// release that supports 256 colors. Windows 10 build 14931 is the first release
    		// that supports 16m/TrueColor.
    		const osRelease = os.release().split('.');
    		if (
    			Number(process.versions.node.split('.')[0]) >= 8 &&
    			Number(osRelease[0]) >= 10 &&
    			Number(osRelease[2]) >= 10586
    		) {
    			return Number(osRelease[2]) >= 14931 ? 3 : 2;
    		}

    		return 1;
    	}

    	if ('CI' in env) {
    		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
    			return 1;
    		}

    		return min;
    	}

    	if ('TEAMCITY_VERSION' in env) {
    		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    	}

    	if (env.COLORTERM === 'truecolor') {
    		return 3;
    	}

    	if ('TERM_PROGRAM' in env) {
    		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    		switch (env.TERM_PROGRAM) {
    			case 'iTerm.app':
    				return version >= 3 ? 3 : 2;
    			case 'Apple_Terminal':
    				return 2;
    			// No default
    		}
    	}

    	if (/-256(color)?$/i.test(env.TERM)) {
    		return 2;
    	}

    	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    		return 1;
    	}

    	if ('COLORTERM' in env) {
    		return 1;
    	}

    	if (env.TERM === 'dumb') {
    		return min;
    	}

    	return min;
    }

    function getSupportLevel(stream) {
    	const level = supportsColor(stream);
    	return translateLevel(level);
    }

    var supportsColor_1 = {
    	supportsColor: getSupportLevel,
    	stdout: getSupportLevel(process.stdout),
    	stderr: getSupportLevel(process.stderr)
    };

    var node = createCommonjsModule(function (module, exports) {
    /**
     * Module dependencies.
     */




    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    try {
    	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    	// eslint-disable-next-line import/no-extraneous-dependencies
    	const supportsColor = supportsColor_1;

    	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
    		exports.colors = [
    			20,
    			21,
    			26,
    			27,
    			32,
    			33,
    			38,
    			39,
    			40,
    			41,
    			42,
    			43,
    			44,
    			45,
    			56,
    			57,
    			62,
    			63,
    			68,
    			69,
    			74,
    			75,
    			76,
    			77,
    			78,
    			79,
    			80,
    			81,
    			92,
    			93,
    			98,
    			99,
    			112,
    			113,
    			128,
    			129,
    			134,
    			135,
    			148,
    			149,
    			160,
    			161,
    			162,
    			163,
    			164,
    			165,
    			166,
    			167,
    			168,
    			169,
    			170,
    			171,
    			172,
    			173,
    			178,
    			179,
    			184,
    			185,
    			196,
    			197,
    			198,
    			199,
    			200,
    			201,
    			202,
    			203,
    			204,
    			205,
    			206,
    			207,
    			208,
    			209,
    			214,
    			215,
    			220,
    			221
    		];
    	}
    } catch (error) {
    	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(key => {
    	return /^debug_/i.test(key);
    }).reduce((obj, key) => {
    	// Camel-case
    	const prop = key
    		.substring(6)
    		.toLowerCase()
    		.replace(/_([a-z])/g, (_, k) => {
    			return k.toUpperCase();
    		});

    	// Coerce string value into JS value
    	let val = process.env[key];
    	if (/^(yes|on|true|enabled)$/i.test(val)) {
    		val = true;
    	} else if (/^(no|off|false|disabled)$/i.test(val)) {
    		val = false;
    	} else if (val === 'null') {
    		val = null;
    	} else {
    		val = Number(val);
    	}

    	obj[prop] = val;
    	return obj;
    }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
    	return 'colors' in exports.inspectOpts ?
    		Boolean(exports.inspectOpts.colors) :
    		tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
    	const {namespace: name, useColors} = this;

    	if (useColors) {
    		const c = this.color;
    		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
    		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

    		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    	} else {
    		args[0] = getDate() + name + ' ' + args[0];
    	}
    }

    function getDate() {
    	if (exports.inspectOpts.hideDate) {
    		return '';
    	}
    	return new Date().toISOString() + ' ';
    }

    /**
     * Invokes `util.format()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
    	return process.stderr.write(util.format(...args) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
    	if (namespaces) {
    		process.env.DEBUG = namespaces;
    	} else {
    		// If you set a process.env field to null or undefined, it gets cast to the
    		// string 'null' or 'undefined'. Just delete instead.
    		delete process.env.DEBUG;
    	}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
    	return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
    	debug.inspectOpts = {};

    	const keys = Object.keys(exports.inspectOpts);
    	for (let i = 0; i < keys.length; i++) {
    		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    	}
    }

    module.exports = common(exports);

    const {formatters} = module.exports;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
    	this.inspectOpts.colors = this.useColors;
    	return util.inspect(v, this.inspectOpts)
    		.replace(/\s*\n\s*/g, ' ');
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
    	this.inspectOpts.colors = this.useColors;
    	return util.inspect(v, this.inspectOpts);
    };
    });
    var node_1 = node.init;
    var node_2 = node.log;
    var node_3 = node.formatArgs;
    var node_4 = node.save;
    var node_5 = node.load;
    var node_6 = node.useColors;
    var node_7 = node.colors;
    var node_8 = node.inspectOpts;

    var src = createCommonjsModule(function (module) {
    /**
     * Detect Electron renderer / nwjs process, which is node, but we should
     * treat as a browser.
     */

    if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    	module.exports = browser;
    } else {
    	module.exports = node;
    }
    });

    var debug = src('guillotine-packer:split-strategies');
    // implementations based off of http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf
    var createSplitRectangle = function (rectangle) { return (__assign(__assign({}, rectangle), { splitFrom: rectangle.id })); };
    var Splitter = /** @class */ (function () {
        function Splitter(kerfSize) {
            this.kerfSize = kerfSize;
        }
        Splitter.prototype.splitHorizontally = function (rectangle, item) {
            debug("splitting " + rectangle.id + " horizontally");
            var rectangle1 = __assign(__assign({}, createSplitRectangle(rectangle)), { x: rectangle.x + item.width + this.kerfSize, width: rectangle.width - item.width - this.kerfSize, height: item.height, id: 'sh-r1' });
            var rectangle2 = __assign(__assign({}, createSplitRectangle(rectangle)), { y: rectangle.y + item.height + this.kerfSize, height: rectangle.height - item.height - this.kerfSize, id: 'sh-r2' });
            return [rectangle1, rectangle2];
        };
        Splitter.prototype.splitVertically = function (rectangle, item) {
            debug("splitting " + rectangle.id + " vertically");
            var rectangle1 = __assign(__assign({}, createSplitRectangle(rectangle)), { y: rectangle.y + item.height + this.kerfSize, width: item.width, height: rectangle.height - item.height - this.kerfSize, id: 'sh-r1' });
            var rectangle2 = __assign(__assign({}, createSplitRectangle(rectangle)), { x: rectangle.x + item.width + this.kerfSize, y: rectangle.y, width: rectangle.width - item.width - this.kerfSize, id: 'sh-r2' });
            return [rectangle1, rectangle2];
        };
        return Splitter;
    }());
    var ShortAxisSplit = /** @class */ (function (_super) {
        __extends(ShortAxisSplit, _super);
        function ShortAxisSplit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShortAxisSplit.prototype.split = function (rectangle, item) {
            if (rectangle.width < rectangle.height) {
                return this.splitHorizontally(rectangle, item);
            }
            else {
                return this.splitVertically(rectangle, item);
            }
        };
        return ShortAxisSplit;
    }(Splitter));
    var LongAxisSplit = /** @class */ (function (_super) {
        __extends(LongAxisSplit, _super);
        function LongAxisSplit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LongAxisSplit.prototype.split = function (rectangle, item) {
            if (rectangle.width > rectangle.height) {
                return this.splitHorizontally(rectangle, item);
            }
            else {
                return this.splitVertically(rectangle, item);
            }
        };
        return LongAxisSplit;
    }(Splitter));
    var ShorterLeftoverAxisSplit = /** @class */ (function (_super) {
        __extends(ShorterLeftoverAxisSplit, _super);
        function ShorterLeftoverAxisSplit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShorterLeftoverAxisSplit.prototype.split = function (rectangle, item) {
            if (rectangle.width - item.width < rectangle.height - item.height) {
                return this.splitHorizontally(rectangle, item);
            }
            else {
                return this.splitVertically(rectangle, item);
            }
        };
        return ShorterLeftoverAxisSplit;
    }(Splitter));
    var LongerLeftoverAxisSplit = /** @class */ (function (_super) {
        __extends(LongerLeftoverAxisSplit, _super);
        function LongerLeftoverAxisSplit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LongerLeftoverAxisSplit.prototype.split = function (rectangle, item) {
            if (rectangle.width - item.width >= rectangle.height - item.height) {
                return this.splitHorizontally(rectangle, item);
            }
            else {
                return this.splitVertically(rectangle, item);
            }
        };
        return LongerLeftoverAxisSplit;
    }(Splitter));
    (function (SplitStrategy) {
        SplitStrategy[SplitStrategy["LongLeftoverAxisSplit"] = 0] = "LongLeftoverAxisSplit";
        SplitStrategy[SplitStrategy["ShortLeftoverAxisSplit"] = 1] = "ShortLeftoverAxisSplit";
        SplitStrategy[SplitStrategy["LongAxisSplit"] = 2] = "LongAxisSplit";
        SplitStrategy[SplitStrategy["ShortAxisSplit"] = 3] = "ShortAxisSplit";
    })(exports.SplitStrategy || (exports.SplitStrategy = {}));
    function GetSplitImplementation(strategy, kerfSize) {
        switch (strategy) {
            case exports.SplitStrategy.LongAxisSplit:
                return new LongAxisSplit(kerfSize);
            case exports.SplitStrategy.ShortAxisSplit:
                return new ShortAxisSplit(kerfSize);
            case exports.SplitStrategy.LongLeftoverAxisSplit:
                return new LongerLeftoverAxisSplit(kerfSize);
            case exports.SplitStrategy.ShortLeftoverAxisSplit:
                return new ShorterLeftoverAxisSplit(kerfSize);
        }
    }

    (function (SelectionStrategy) {
        SelectionStrategy[SelectionStrategy["BEST_SHORT_SIDE_FIT"] = 0] = "BEST_SHORT_SIDE_FIT";
        SelectionStrategy[SelectionStrategy["BEST_LONG_SIDE_FIT"] = 1] = "BEST_LONG_SIDE_FIT";
        SelectionStrategy[SelectionStrategy["BEST_AREA_FIT"] = 2] = "BEST_AREA_FIT";
    })(exports.SelectionStrategy || (exports.SelectionStrategy = {}));
    var SelectionImplementation = /** @class */ (function () {
        function SelectionImplementation() {
        }
        SelectionImplementation.prototype.select = function (freeRectangles, itemToPlace) {
            var _this = this;
            var bestRect = freeRectangles
                .filter(function (freeRect) {
                return freeRect.width - itemToPlace.width >= 0 && freeRect.height - itemToPlace.height >= 0;
            })
                .map(function (r) { return ({ rectangle: r, sortValue: _this.generateSortValue(r, itemToPlace) }); })
                .sort(function (a, b) { return (a.sortValue > b.sortValue ? 1 : -1); })[0];
            return bestRect ? bestRect.rectangle : null;
        };
        return SelectionImplementation;
    }());
    var BestShortSideFit = /** @class */ (function (_super) {
        __extends(BestShortSideFit, _super);
        function BestShortSideFit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BestShortSideFit.prototype.generateSortValue = function (freeRectangle, itemToPlace) {
            var width = itemToPlace.width, height = itemToPlace.height;
            return Math.min(freeRectangle.width - width, freeRectangle.height - height);
        };
        return BestShortSideFit;
    }(SelectionImplementation));
    var BestLongSideFit = /** @class */ (function (_super) {
        __extends(BestLongSideFit, _super);
        function BestLongSideFit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BestLongSideFit.prototype.generateSortValue = function (freeRectangle, itemToPlace) {
            var width = itemToPlace.width, height = itemToPlace.height;
            return Math.max(freeRectangle.width - width, freeRectangle.height - height);
        };
        return BestLongSideFit;
    }(SelectionImplementation));
    var BestAreaFit = /** @class */ (function (_super) {
        __extends(BestAreaFit, _super);
        function BestAreaFit() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BestAreaFit.prototype.generateSortValue = function (freeRectangle) {
            return freeRectangle.width * freeRectangle.height;
        };
        return BestAreaFit;
    }(SelectionImplementation));
    function GetSelectionImplementation(strategy) {
        switch (strategy) {
            case exports.SelectionStrategy.BEST_AREA_FIT:
                return new BestAreaFit();
            case exports.SelectionStrategy.BEST_LONG_SIDE_FIT:
                return new BestLongSideFit();
            case exports.SelectionStrategy.BEST_SHORT_SIDE_FIT:
                return new BestShortSideFit();
        }
    }

    var area = function (item) { return item.height * item.width; };
    var perimeter = function (item) { return item.height * 2 + item.width * 2; };
    var sides = function (item) { return ({
        short: Math.min(item.width, item.height),
        long: Math.max(item.width, item.height)
    }); };
    var Sorter = /** @class */ (function () {
        function Sorter(direction) {
            this.direction = direction;
        }
        Sorter.prototype.sort = function (items) {
            var sortedItems = __spreadArrays(items).sort(this.comparer);
            return this.direction === SortDirection.DESC ? sortedItems.reverse() : sortedItems;
        };
        return Sorter;
    }());
    var Area = /** @class */ (function (_super) {
        __extends(Area, _super);
        function Area() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Area.prototype.comparer = function (a, b) {
            return area(a) < area(b) ? -1 : 1;
        };
        return Area;
    }(Sorter));
    var ShortSide = /** @class */ (function (_super) {
        __extends(ShortSide, _super);
        function ShortSide() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShortSide.prototype.comparer = function (a, b) {
            var aSides = sides(a);
            var bSides = sides(b);
            if (aSides.short === bSides.short) {
                return aSides.long < bSides.long ? -1 : 1;
            }
            else {
                return aSides.short < bSides.short ? -1 : 1;
            }
        };
        return ShortSide;
    }(Sorter));
    var LongSide = /** @class */ (function (_super) {
        __extends(LongSide, _super);
        function LongSide() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LongSide.prototype.comparer = function (a, b) {
            var aSides = sides(a);
            var bSides = sides(b);
            if (aSides.long === bSides.long) {
                return aSides.short < bSides.short ? -1 : 1;
            }
            else {
                return aSides.long < bSides.long ? -1 : 1;
            }
        };
        return LongSide;
    }(Sorter));
    var Perimeter = /** @class */ (function (_super) {
        __extends(Perimeter, _super);
        function Perimeter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Perimeter.prototype.comparer = function (a, b) {
            return perimeter(a) < perimeter(b) ? -1 : 1;
        };
        return Perimeter;
    }(Sorter));
    var Differences = /** @class */ (function (_super) {
        __extends(Differences, _super);
        function Differences() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Differences.prototype.comparer = function (a, b) {
            return Math.abs(a.width - a.height) < Math.abs(b.width - b.height) ? -1 : 1;
        };
        return Differences;
    }(Sorter));
    var Ratio = /** @class */ (function (_super) {
        __extends(Ratio, _super);
        function Ratio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Ratio.prototype.comparer = function (a, b) {
            return a.width / a.height < b.width / b.height ? -1 : 1;
        };
        return Ratio;
    }(Sorter));
    (function (SortStrategy) {
        SortStrategy[SortStrategy["Area"] = 0] = "Area";
        SortStrategy[SortStrategy["ShortSide"] = 1] = "ShortSide";
        SortStrategy[SortStrategy["LongSide"] = 2] = "LongSide";
        SortStrategy[SortStrategy["Perimeter"] = 3] = "Perimeter";
        SortStrategy[SortStrategy["Differences"] = 4] = "Differences";
        SortStrategy[SortStrategy["Ratio"] = 5] = "Ratio";
    })(exports.SortStrategy || (exports.SortStrategy = {}));
    var SortDirection;
    (function (SortDirection) {
        SortDirection[SortDirection["ASC"] = 0] = "ASC";
        SortDirection[SortDirection["DESC"] = 1] = "DESC";
    })(SortDirection || (SortDirection = {}));
    function GetSortImplementation(strategy, direction) {
        var impl;
        switch (strategy) {
            case exports.SortStrategy.Area:
                impl = Area;
                break;
            case exports.SortStrategy.Differences:
                impl = Differences;
                break;
            case exports.SortStrategy.LongSide:
                impl = LongSide;
                break;
            case exports.SortStrategy.Perimeter:
                impl = Perimeter;
                break;
            case exports.SortStrategy.Ratio:
                impl = Ratio;
                break;
            case exports.SortStrategy.ShortSide:
                impl = ShortSide;
                break;
        }
        return new impl(direction);
    }

    var debug$1 = src('guillotine-packer:pack-strategy');
    function PackStrategy(_a) {
        var binHeight = _a.binHeight, binWidth = _a.binWidth, items = _a.items, selectionStrategy = _a.selectionStrategy, splitStrategy = _a.splitStrategy, sortStrategy = _a.sortStrategy, sortOrder = _a.sortOrder, kerfSize = _a.kerfSize, allowRotation = _a.allowRotation;
        debug$1("Executing! split strategy: " + splitStrategy + ", selection strategy: " + selectionStrategy + ", sortStrategy: " + sortStrategy + ", sortOrder: " + sortOrder);
        var binCount = 0;
        var freeRectangles = [];
        var createBin = function () {
            binCount++;
            debug$1("creating bin " + binCount);
            freeRectangles.push({
                width: binWidth,
                height: binHeight,
                x: 0,
                y: 0,
                bin: binCount,
                id: 'root'
            });
        };
        var splitter = GetSplitImplementation(splitStrategy, kerfSize);
        var selector = GetSelectionImplementation(selectionStrategy);
        var sorter = GetSortImplementation(sortStrategy, sortOrder);
        var sortedItems = sorter.sort(items);
        var rotateItem = function (item) {
            return __assign(__assign({}, item), { height: item.width, width: item.height });
        };
        var splitRectangle = function (_a) {
            var rectangle = _a.rectangle, item = _a.item;
            return splitter.split(rectangle, item).filter(function (r) { return r.width > 0 && r.height > 0; });
        };
        var getSelectionOption = function (item) {
            var rectangle = selector.select(freeRectangles, item);
            debug$1("for item " + JSON.stringify(item) + ", selected " + JSON.stringify(rectangle));
            if (!rectangle) {
                return null;
            }
            var splitRectangles = splitRectangle({ rectangle: rectangle, item: item });
            return {
                rectangle: rectangle,
                splitRectangles: splitRectangles,
                item: item
            };
        };
        var selectRectangleOption = function (item) {
            var originalOption = getSelectionOption(item);
            var rotatedOption = null;
            var rotatedItem;
            if (allowRotation) {
                rotatedItem = rotateItem(item);
                rotatedOption = getSelectionOption(rotatedItem);
            }
            if (originalOption === null && rotatedOption === null) {
                debug$1("No free rectangles found for", item);
                return null;
            }
            else if (originalOption === null) {
                debug$1("Original item didn't fit, using rotated", item);
                return rotatedOption;
            }
            else if (rotatedOption === null) {
                debug$1("Rotated item didn't fit, using original option", item);
                return originalOption;
            }
            else {
                var getBiggestSplitRectangle = function (_a) {
                    var splitRectangles = _a.splitRectangles;
                    return Math.max.apply(Math, splitRectangles.map(function (split) { return split.height * split.width; }));
                };
                var originalMax = getBiggestSplitRectangle(originalOption);
                var rotatedMax = getBiggestSplitRectangle(rotatedOption);
                debug$1("Original max area " + originalMax + ", rotated max area " + rotatedMax);
                if (getBiggestSplitRectangle(originalOption) >= getBiggestSplitRectangle(rotatedOption)) {
                    debug$1("Going with original placement option");
                    return originalOption;
                }
                else {
                    debug$1("Going with rotated placement option");
                    return rotatedOption;
                }
            }
        };
        var packedItems = sortedItems
            .map(function (item, idx) {
            debug$1('packing item', item);
            var selectedOption = selectRectangleOption(item);
            if (!selectedOption) {
                createBin();
                selectedOption = selectRectangleOption(item);
            }
            if (!selectedOption) {
                throw new Error("item at index " + idx + " with dimensions " + item.width + "x" + item.height + " exceeds bin dimensions of " + binWidth + "x" + binHeight);
            }
            var rectangle = selectedOption.rectangle, splitRectangles = selectedOption.splitRectangles;
            debug$1('selected rectangle', rectangle);
            var _a = selectedOption.item, width = _a.width, height = _a.height, otherItemProps = __rest(_a, ["width", "height"]);
            var packedItem = {
                item: otherItemProps,
                width: width,
                height: height,
                x: rectangle.x,
                y: rectangle.y,
                bin: rectangle.bin
            };
            debug$1('packed item', packedItem);
            debug$1('free rectangles pre split', freeRectangles);
            var rectIndex = freeRectangles.findIndex(function (r) { return r === rectangle; });
            freeRectangles.splice.apply(freeRectangles, __spreadArrays([rectIndex, 1], splitRectangles));
            debug$1('free rectangles post split', freeRectangles);
            return packedItem;
        })
            .reduce(function (bins, item) {
            if (bins.length >= item.bin) {
                bins[item.bin - 1].push(item);
            }
            else {
                bins.push([item]);
            }
            return bins;
        }, []);
        return {
            sortStrategy: sortStrategy,
            sortOrder: sortOrder,
            packedItems: packedItems,
            splitStrategy: splitStrategy,
            selectionStrategy: selectionStrategy
        };
    }

    var f = function (a, b) {
        var _a;
        return (_a = []).concat.apply(_a, a.map(function (d) { return b.map(function (e) { return [].concat(d, e); }); }));
    };
    var cartesian = function (a, b) {
        var c = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            c[_i - 2] = arguments[_i];
        }
        return b ? cartesian.apply(void 0, __spreadArrays([f(a, b)], c)) : a;
    };

    var debug$2 = src('guillotine-packer');
    function Packer(_a, _b) {
        var binHeight = _a.binHeight, binWidth = _a.binWidth, items = _a.items;
        var _c = _b === void 0 ? {} : _b, selectionStrategy = _c.selectionStrategy, splitStrategy = _c.splitStrategy, sortStrategy = _c.sortStrategy, _d = _c.kerfSize, kerfSize = _d === void 0 ? 0 : _d, _e = _c.allowRotation, allowRotation = _e === void 0 ? true : _e;
        function enumToArray(enumVariable) {
            return Object.values(enumVariable)
                .filter(function (value) { return parseInt(value, 10) >= 0; })
                .map(function (value) { return value; });
        }
        var selectionStrategies = selectionStrategy !== undefined ? [selectionStrategy] : enumToArray(exports.SelectionStrategy);
        var splitStrategies = splitStrategy !== undefined ? [splitStrategy] : enumToArray(exports.SplitStrategy);
        var sortStrategies = sortStrategy !== undefined ? [sortStrategy] : enumToArray(exports.SortStrategy);
        var allStrategies = cartesian(selectionStrategies, splitStrategies, sortStrategies, [
            SortDirection.ASC,
            SortDirection.DESC
        ]);
        return allStrategies
            .map(function (_a) {
            var selectionStrategy = _a[0], splitStrategy = _a[1], sortStrategy = _a[2], sortOrder = _a[3];
            return PackStrategy({
                binWidth: binWidth,
                binHeight: binHeight,
                items: items,
                splitStrategy: splitStrategy,
                selectionStrategy: selectionStrategy,
                sortStrategy: sortStrategy,
                sortOrder: sortOrder,
                kerfSize: kerfSize,
                allowRotation: allowRotation
            });
        })
            .reduce(function (bestCompressed, packResult) {
            var splitStrategy = packResult.splitStrategy, sortStrategy = packResult.sortStrategy, selectionStrategy = packResult.selectionStrategy, sortOrder = packResult.sortOrder, packedItems = packResult.packedItems;
            debug$2("Result for split strategy: " + splitStrategy + ", selection strategy: " + selectionStrategy + ", sortStrategy: " + sortStrategy + ", sortOrder: " + sortOrder + " - " + packedItems.length + " bin(s)");
            if (!bestCompressed || packedItems.length < bestCompressed.length) {
                return packedItems;
            }
            else {
                return bestCompressed;
            }
        }, null);
    }

    exports.packer = Packer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=guillotine-packer.umd.js.map
